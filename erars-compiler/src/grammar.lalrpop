use crate::{Function, FunctionInfo, FunctionHeader, EventFlags, Expr, Stmt, LexicalError, Token, PrintFlags, BinaryOperator};
use source_span::{Position, Span};

grammar;

pub Function: Function = {
    <header:FunctionHeader> <body:Body> => {
        Function {
            header,
            body,
        }
    },
};

FunctionHeader: FunctionHeader = {
    "@" <name:ident> <infos: FunctionInfo*> => {
        FunctionHeader {
            name,
            infos,
        }
    },
};

FunctionInfo: FunctionInfo = {
    "#" <info:ident> => {
        match info.as_str() {
            "PRI" => FunctionInfo::EventFlag(EventFlags::Pre),
            "LATER" => FunctionInfo::EventFlag(EventFlags::Later),
            "SINGLE" => FunctionInfo::EventFlag(EventFlags::Single),
            _ => unreachable!(),
        }
    },
};

pub Body: Vec<Stmt> = {
    <lines: ProgramLine*> => lines,
};

ProgramLine: Stmt = {
    <flags:PRINT> <text:string> => Stmt::Print(flags, text),
    <flags:PRINTFORM> <text:string> <parts:PrintFormPart*> => Stmt::PrintForm(flags, text, parts),
};

PrintFormPart: (Expr, String) = {
    <expr:Expr> <text:string> => (expr, text),
}

Expr: Expr = {
    #[precedence(level = "0")]
    <int> => Expr::IntLit(<>),
    <string> => Expr::StringLit(<>),
    "(" <Expr> ")",

    #[precedence(level = "1")] #[assoc(side = "left")]
    <lhs:Expr> "*" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Mul, Box::new(rhs)),
    <lhs:Expr> "/" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Div, Box::new(rhs)),

    #[precedence(level = "2")] #[assoc(side = "left")]
    <lhs:Expr> "+" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Add, Box::new(rhs)),
    <lhs:Expr> "-" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Sub, Box::new(rhs)),
};

extern {
    type Location = (Position, Position);
    type Error = LexicalError;

    enum Token {
        PRINT => Token::Print(<PrintFlags>),
        PRINTFORM => Token::PrintForm(<PrintFlags>),
        "+" => Token::Plus,
        "*" => Token::Star,
        "-" => Token::Minus,
        "/" => Token::Slash,
        "(" => Token::OpenParan,
        ")" => Token::CloseParan,
        "@" => Token::At,
        "#" => Token::Sharp,
        ident => Token::Ident(<String>),
        string => Token::StringLit(<String>),
        int => Token::IntLit(<i64>),
    }
}
