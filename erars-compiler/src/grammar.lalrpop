use crate::{Function, FunctionInfo, FunctionHeader, EventFlags, Expr, Stmt, LexicalError, Token, PrintFlags, BinaryOperator, UnaryOperator};
use source_span::{Position, Span};

grammar;

pub Program: Vec<Function> = {
    <Function*> => <>,
}

pub Function: Function = {
    <header:FunctionHeader> <body:Body> => {
        Function {
            header,
            body,
        }
    },
}

FunctionHeader: FunctionHeader = {
    "@" <name:ident> <infos: FunctionInfo*> => {
        FunctionHeader {
            name,
            infos,
        }
    },
}

FunctionInfo: FunctionInfo = {
    "#" <info:ident> => {
        match info.as_str() {
            "PRI" => FunctionInfo::EventFlag(EventFlags::Pre),
            "LATER" => FunctionInfo::EventFlag(EventFlags::Later),
            "SINGLE" => FunctionInfo::EventFlag(EventFlags::Single),
            _ => unreachable!(),
        }
    },
}

pub Body: Vec<Stmt> = {
    <lines: ProgramLine*> => lines,
}

pub ProgramLine: Stmt = {
    <flags:PRINT> <text:string> => Stmt::Print(flags, text),
    <flags:PRINTFORM> <text:string> <parts:(<Expr> <string>)*> => Stmt::PrintForm(flags, text, parts),
}

ExprReset = <Expr>;

pub Expr: Expr = {
    #[precedence(level = "0")]
    <int> => Expr::IntLit(<>),
    <string> => Expr::StringLit(<>),
    "(" <ExprReset> ")",

    #[precedence(level = "1")] #[assoc(side = "none")]
    <ident> => Expr::Var(<>, vec![]),

    #[precedence(level = "2")] #[assoc(side = "none")]
    <name:ident> <args:(":" <Expr>)+> => Expr::Var(name, args),

    #[precedence(level = "10")] #[assoc(side = "all")]
    "!" <Expr> => Expr::UnaryopExpr(Box::new(<>), UnaryOperator::Not),
    "~" <Expr> => Expr::UnaryopExpr(Box::new(<>), UnaryOperator::BitNot),

    #[precedence(level = "20")] #[assoc(side = "left")]
    <lhs:Expr> "*" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Mul, Box::new(rhs)),
    <lhs:Expr> "/" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Div, Box::new(rhs)),
    <lhs:Expr> "%" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Rem, Box::new(rhs)),

    #[precedence(level = "21")] #[assoc(side = "left")]
    <lhs:Expr> "+" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Add, Box::new(rhs)),
    <lhs:Expr> "-" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Sub, Box::new(rhs)),

    #[precedence(level = "30")] #[assoc(side = "left")]
    <lhs:Expr> ">" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Gt, Box::new(rhs)),
    <lhs:Expr> ">=" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Ge, Box::new(rhs)),
    <lhs:Expr> "<" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Lt, Box::new(rhs)),
    <lhs:Expr> "<=" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Le, Box::new(rhs)),

    #[precedence(level = "31")] #[assoc(side = "left")]
    <lhs:Expr> "==" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::Equal, Box::new(rhs)),
    <lhs:Expr> "!=" <rhs:Expr> => Expr::BinopExpr(Box::new(lhs), BinaryOperator::NotEqual, Box::new(rhs)),

    #[precedence(level = "50")] #[assoc(side = "left")]
    <cond:Expr> "?" <if_true:Expr> "#" <or_false:Expr> => Expr::CondExpr(Box::new(cond), Box::new(if_true), Box::new(or_false)),
}

extern {
    type Location = (Position, Position);
    type Error = LexicalError;

    enum Token {
        PRINT => Token::Print(<PrintFlags>),
        PRINTFORM => Token::PrintForm(<PrintFlags>),
        "+" => Token::Plus,
        "*" => Token::Star,
        "-" => Token::Minus,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "!" => Token::Exclamation,
        "~" => Token::Tilde,
        "?" => Token::Question,
        ":" => Token::Colon,
        "(" => Token::OpenParan,
        ")" => Token::CloseParan,
        "{" => Token::OpenBrace,
        "}" => Token::CloseBrace,
        "," => Token::Comma,
        "." => Token::Period,
        "@" => Token::At,
        "#" => Token::Sharp,
        "==" => Token::Equal,
        "!=" => Token::NotEqual,
        "<" => Token::Lt,
        "<=" => Token::Le,
        ">" => Token::Gt,
        ">=" => Token::Ge,
        ident => Token::Ident(<String>),
        string => Token::StringLit(<String>),
        int => Token::IntLit(<i64>),
    }
}
