// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONSOLE_LINE_PART_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONSOLE_LINE_PART_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONSOLE_LINE_PART_TYPE: [ConsoleLinePartType; 3] = [
  ConsoleLinePartType::Text,
  ConsoleLinePartType::Line,
  ConsoleLinePartType::Button,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ConsoleLinePartType(pub u8);
#[allow(non_upper_case_globals)]
impl ConsoleLinePartType {
  pub const Text: Self = Self(0);
  pub const Line: Self = Self(1);
  pub const Button: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Text,
    Self::Line,
    Self::Button,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Text => Some("Text"),
      Self::Line => Some("Line"),
      Self::Button => Some("Button"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for ConsoleLinePartType {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ConsoleLinePartType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for ConsoleLinePartType {
    type Output = ConsoleLinePartType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ConsoleLinePartType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ConsoleLinePartType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ConsoleLinePartType {}
#[allow(non_upper_case_globals)]
mod bitflags_font_style {
  flatbuffers::bitflags::bitflags! {
    #[derive(Default)]
    pub struct FontStyle: u32 {
      const BOLD = 1;
      const ITALIC = 2;
      const STRIKELINE = 4;
      const UNDERLINE = 8;
    }
  }
}
pub use self::bitflags_font_style::FontStyle;

impl<'a> flatbuffers::Follow<'a> for FontStyle {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u32>(buf, loc)
    };
    unsafe { Self::from_bits_unchecked(b) }
  }
}

impl flatbuffers::Push for FontStyle {
    type Output = FontStyle;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u32>(dst, self.bits()); }
    }
}

impl flatbuffers::EndianScalar for FontStyle {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u32::to_le(self.bits());
    unsafe { Self::from_bits_unchecked(b) }
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u32::from_le(self.bits());
    unsafe { Self::from_bits_unchecked(b) }
  }
}

impl<'a> flatbuffers::Verifiable for FontStyle {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FontStyle {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LINE_ALIGN: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LINE_ALIGN: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LINE_ALIGN: [LineAlign; 3] = [
  LineAlign::Left,
  LineAlign::Center,
  LineAlign::Right,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LineAlign(pub u8);
#[allow(non_upper_case_globals)]
impl LineAlign {
  pub const Left: Self = Self(0);
  pub const Center: Self = Self(1);
  pub const Right: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Left,
    Self::Center,
    Self::Right,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Left => Some("Left"),
      Self::Center => Some("Center"),
      Self::Right => Some("Right"),
      _ => None,
    }
  }
}
impl std::fmt::Debug for LineAlign {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LineAlign {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for LineAlign {
    type Output = LineAlign;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for LineAlign {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LineAlign {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LineAlign {}
// struct Color, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Color(pub [u8; 3]);
impl Default for Color { 
  fn default() -> Self { 
    Self([0; 3])
  }
}
impl std::fmt::Debug for Color {
  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
    f.debug_struct("Color")
      .field("r", &self.r())
      .field("g", &self.g())
      .field("b", &self.b())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Color {}
impl flatbuffers::SafeSliceAccess for Color {}
impl<'a> flatbuffers::Follow<'a> for Color {
  type Inner = &'a Color;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Color>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Color {
  type Inner = &'a Color;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Color>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Color {
    type Output = Color;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Color as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Color {
    type Output = Color;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Color as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Color {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Color {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    r: u8,
    g: u8,
    b: u8,
  ) -> Self {
    let mut s = Self([0; 3]);
    s.set_r(r);
    s.set_g(g);
    s.set_b(b);
    s
  }

  pub fn r(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<u8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_r(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u8 as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<u8>(),
      );
    }
  }

  pub fn g(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<u8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[1..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_g(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u8 as *const u8,
        self.0[1..].as_mut_ptr(),
        core::mem::size_of::<u8>(),
      );
    }
  }

  pub fn b(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<u8>::uninit();
    unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<u8>(),
      );
      mem.assume_init()
    }.from_little_endian()
  }

  pub fn set_b(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const u8 as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<u8>(),
      );
    }
  }

}

pub enum TextStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TextStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TextStyle<'a> {
  type Inner = TextStyle<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TextStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_FONT_FAMILY: flatbuffers::VOffsetT = 6;
  pub const VT_FONT_STYLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TextStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TextStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<TextStyle<'bldr>> {
    let mut builder = TextStyleBuilder::new(_fbb);
    builder.add_font_style(args.font_style);
    if let Some(x) = args.font_family { builder.add_font_family(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<&'a Color> {
    self._tab.get::<Color>(TextStyle::VT_COLOR, None)
  }
  #[inline]
  pub fn font_family(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TextStyle::VT_FONT_FAMILY, None)
  }
  #[inline]
  pub fn font_style(&self) -> FontStyle {
    self._tab.get::<FontStyle>(TextStyle::VT_FONT_STYLE, Some(Default::default())).unwrap()
  }
}

impl flatbuffers::Verifiable for TextStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Color>("color", Self::VT_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("font_family", Self::VT_FONT_FAMILY, false)?
     .visit_field::<FontStyle>("font_style", Self::VT_FONT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct TextStyleArgs<'a> {
    pub color: Option<&'a Color>,
    pub font_family: Option<flatbuffers::WIPOffset<&'a str>>,
    pub font_style: FontStyle,
}
impl<'a> Default for TextStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    TextStyleArgs {
      color: None,
      font_family: None,
      font_style: Default::default(),
    }
  }
}

pub struct TextStyleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TextStyleBuilder<'a, 'b> {
  #[inline]
  pub fn add_color(&mut self, color: &Color) {
    self.fbb_.push_slot_always::<&Color>(TextStyle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_font_family(&mut self, font_family: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TextStyle::VT_FONT_FAMILY, font_family);
  }
  #[inline]
  pub fn add_font_style(&mut self, font_style: FontStyle) {
    self.fbb_.push_slot::<FontStyle>(TextStyle::VT_FONT_STYLE, font_style, Default::default());
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TextStyleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TextStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TextStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for TextStyle<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("TextStyle");
      ds.field("color", &self.color());
      ds.field("font_family", &self.font_family());
      ds.field("font_style", &self.font_style());
      ds.finish()
  }
}
pub enum ConsoleLineSubPartOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConsoleLineSubPart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConsoleLineSubPart<'a> {
  type Inner = ConsoleLineSubPart<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ConsoleLineSubPart<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConsoleLineSubPart { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConsoleLineSubPartArgs<'args>
  ) -> flatbuffers::WIPOffset<ConsoleLineSubPart<'bldr>> {
    let mut builder = ConsoleLineSubPartBuilder::new(_fbb);
    if let Some(x) = args.color { builder.add_color(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConsoleLineSubPart::VT_TEXT, None)
  }
  #[inline]
  pub fn color(&self) -> Option<&'a Color> {
    self._tab.get::<Color>(ConsoleLineSubPart::VT_COLOR, None)
  }
}

impl flatbuffers::Verifiable for ConsoleLineSubPart<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<Color>("color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct ConsoleLineSubPartArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub color: Option<&'a Color>,
}
impl<'a> Default for ConsoleLineSubPartArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConsoleLineSubPartArgs {
      text: None,
      color: None,
    }
  }
}

pub struct ConsoleLineSubPartBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConsoleLineSubPartBuilder<'a, 'b> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConsoleLineSubPart::VT_TEXT, text);
  }
  #[inline]
  pub fn add_color(&mut self, color: &Color) {
    self.fbb_.push_slot_always::<&Color>(ConsoleLineSubPart::VT_COLOR, color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConsoleLineSubPartBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConsoleLineSubPartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConsoleLineSubPart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ConsoleLineSubPart<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ConsoleLineSubPart");
      ds.field("text", &self.text());
      ds.field("color", &self.color());
      ds.finish()
  }
}
pub enum ConsoleLinePartOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConsoleLinePart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConsoleLinePart<'a> {
  type Inner = ConsoleLinePart<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ConsoleLinePart<'a> {
  pub const VT_TY: flatbuffers::VOffsetT = 4;
  pub const VT_INNER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConsoleLinePart { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConsoleLinePartArgs<'args>
  ) -> flatbuffers::WIPOffset<ConsoleLinePart<'bldr>> {
    let mut builder = ConsoleLinePartBuilder::new(_fbb);
    if let Some(x) = args.inner { builder.add_inner(x); }
    builder.add_ty(args.ty);
    builder.finish()
  }


  #[inline]
  pub fn ty(&self) -> ConsoleLinePartType {
    self._tab.get::<ConsoleLinePartType>(ConsoleLinePart::VT_TY, Some(ConsoleLinePartType::Text)).unwrap()
  }
  #[inline]
  pub fn inner(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLineSubPart<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLineSubPart>>>>(ConsoleLinePart::VT_INNER, None).unwrap()
  }
}

impl flatbuffers::Verifiable for ConsoleLinePart<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ConsoleLinePartType>("ty", Self::VT_TY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleLineSubPart>>>>("inner", Self::VT_INNER, true)?
     .finish();
    Ok(())
  }
}
pub struct ConsoleLinePartArgs<'a> {
    pub ty: ConsoleLinePartType,
    pub inner: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLineSubPart<'a>>>>>,
}
impl<'a> Default for ConsoleLinePartArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConsoleLinePartArgs {
      ty: ConsoleLinePartType::Text,
      inner: None, // required field
    }
  }
}

pub struct ConsoleLinePartBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConsoleLinePartBuilder<'a, 'b> {
  #[inline]
  pub fn add_ty(&mut self, ty: ConsoleLinePartType) {
    self.fbb_.push_slot::<ConsoleLinePartType>(ConsoleLinePart::VT_TY, ty, ConsoleLinePartType::Text);
  }
  #[inline]
  pub fn add_inner(&mut self, inner: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ConsoleLineSubPart<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConsoleLinePart::VT_INNER, inner);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConsoleLinePartBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConsoleLinePartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConsoleLinePart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ConsoleLinePart::VT_INNER,"inner");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ConsoleLinePart<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ConsoleLinePart");
      ds.field("ty", &self.ty());
      ds.field("inner", &self.inner());
      ds.finish()
  }
}
pub enum ConsoleLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConsoleLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConsoleLine<'a> {
  type Inner = ConsoleLine<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ConsoleLine<'a> {
  pub const VT_ALIGN: flatbuffers::VOffsetT = 4;
  pub const VT_PARTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConsoleLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConsoleLineArgs<'args>
  ) -> flatbuffers::WIPOffset<ConsoleLine<'bldr>> {
    let mut builder = ConsoleLineBuilder::new(_fbb);
    if let Some(x) = args.parts { builder.add_parts(x); }
    builder.add_align(args.align);
    builder.finish()
  }


  #[inline]
  pub fn align(&self) -> LineAlign {
    self._tab.get::<LineAlign>(ConsoleLine::VT_ALIGN, Some(LineAlign::Left)).unwrap()
  }
  #[inline]
  pub fn parts(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLinePart<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLinePart>>>>(ConsoleLine::VT_PARTS, None).unwrap()
  }
}

impl flatbuffers::Verifiable for ConsoleLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<LineAlign>("align", Self::VT_ALIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleLinePart>>>>("parts", Self::VT_PARTS, true)?
     .finish();
    Ok(())
  }
}
pub struct ConsoleLineArgs<'a> {
    pub align: LineAlign,
    pub parts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLinePart<'a>>>>>,
}
impl<'a> Default for ConsoleLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConsoleLineArgs {
      align: LineAlign::Left,
      parts: None, // required field
    }
  }
}

pub struct ConsoleLineBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConsoleLineBuilder<'a, 'b> {
  #[inline]
  pub fn add_align(&mut self, align: LineAlign) {
    self.fbb_.push_slot::<LineAlign>(ConsoleLine::VT_ALIGN, align, LineAlign::Left);
  }
  #[inline]
  pub fn add_parts(&mut self, parts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ConsoleLinePart<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConsoleLine::VT_PARTS, parts);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConsoleLineBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConsoleLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConsoleLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ConsoleLine::VT_PARTS,"parts");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ConsoleLine<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ConsoleLine");
      ds.field("align", &self.align());
      ds.field("parts", &self.parts());
      ds.finish()
  }
}
pub enum RedrawRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RedrawRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RedrawRequest<'a> {
  type Inner = RedrawRequest<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RedrawRequest<'a> {
  pub const VT_REBUILD: flatbuffers::VOffsetT = 4;
  pub const VT_BG_COLOR: flatbuffers::VOffsetT = 6;
  pub const VT_HL_COLOR: flatbuffers::VOffsetT = 8;
  pub const VT_LINES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RedrawRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RedrawRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<RedrawRequest<'bldr>> {
    let mut builder = RedrawRequestBuilder::new(_fbb);
    if let Some(x) = args.lines { builder.add_lines(x); }
    if let Some(x) = args.hl_color { builder.add_hl_color(x); }
    if let Some(x) = args.bg_color { builder.add_bg_color(x); }
    builder.add_rebuild(args.rebuild);
    builder.finish()
  }


  #[inline]
  pub fn rebuild(&self) -> bool {
    self._tab.get::<bool>(RedrawRequest::VT_REBUILD, Some(false)).unwrap()
  }
  #[inline]
  pub fn bg_color(&self) -> Option<&'a Color> {
    self._tab.get::<Color>(RedrawRequest::VT_BG_COLOR, None)
  }
  #[inline]
  pub fn hl_color(&self) -> Option<&'a Color> {
    self._tab.get::<Color>(RedrawRequest::VT_HL_COLOR, None)
  }
  #[inline]
  pub fn lines(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLine<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLine>>>>(RedrawRequest::VT_LINES, None).unwrap()
  }
}

impl flatbuffers::Verifiable for RedrawRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("rebuild", Self::VT_REBUILD, false)?
     .visit_field::<Color>("bg_color", Self::VT_BG_COLOR, false)?
     .visit_field::<Color>("hl_color", Self::VT_HL_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleLine>>>>("lines", Self::VT_LINES, true)?
     .finish();
    Ok(())
  }
}
pub struct RedrawRequestArgs<'a> {
    pub rebuild: bool,
    pub bg_color: Option<&'a Color>,
    pub hl_color: Option<&'a Color>,
    pub lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleLine<'a>>>>>,
}
impl<'a> Default for RedrawRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    RedrawRequestArgs {
      rebuild: false,
      bg_color: None,
      hl_color: None,
      lines: None, // required field
    }
  }
}

pub struct RedrawRequestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RedrawRequestBuilder<'a, 'b> {
  #[inline]
  pub fn add_rebuild(&mut self, rebuild: bool) {
    self.fbb_.push_slot::<bool>(RedrawRequest::VT_REBUILD, rebuild, false);
  }
  #[inline]
  pub fn add_bg_color(&mut self, bg_color: &Color) {
    self.fbb_.push_slot_always::<&Color>(RedrawRequest::VT_BG_COLOR, bg_color);
  }
  #[inline]
  pub fn add_hl_color(&mut self, hl_color: &Color) {
    self.fbb_.push_slot_always::<&Color>(RedrawRequest::VT_HL_COLOR, hl_color);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ConsoleLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RedrawRequest::VT_LINES, lines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RedrawRequestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RedrawRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RedrawRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RedrawRequest::VT_LINES,"lines");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for RedrawRequest<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("RedrawRequest");
      ds.field("rebuild", &self.rebuild());
      ds.field("bg_color", &self.bg_color());
      ds.field("hl_color", &self.hl_color());
      ds.field("lines", &self.lines());
      ds.finish()
  }
}
